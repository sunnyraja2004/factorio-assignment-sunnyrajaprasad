# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NvK0ZenoVq5U0JvX2TNqIe3l-Tp2x6Kx
"""

#!/usr/bin/env python3
import sys, json, math
from collections import defaultdict, OrderedDict

# We use SciPy linprog for a precise LP with constraints and a convex tie-break.
# If SciPy is unavailable, see the fallback note at the bottom.
try:
    from scipy.optimize import linprog
except Exception as e:
    print(json.dumps({
        "status": "infeasible",
        "max_feasible_target_per_min": 0.0,
        "bottleneck_hint": ["scipy.optimize.linprog not available: " + str(e)]
    }))
    sys.exit(0)

ABS_TOL = 1e-9

def ordered(d):  # deterministic ordering by key
    return OrderedDict(sorted(d.items(), key=lambda kv: kv[0]))

def main():
    data = json.load(sys.stdin)

    machines = ordered(data["machines"])
    recipes = ordered(data["recipes"])
    modules = ordered(data.get("modules", {}))
    limits = data["limits"]
    raw_caps = ordered(limits.get("raw_supply_per_min", {}))
    max_machines = ordered(limits.get("max_machines", {}))
    target_item = data["target"]["item"]
    target_rate_req = float(data["target"]["rate_per_min"])

    # Pre-compute effective machine speed per recipe
    # eff_crafts_per_min(r) = machines[m].crafts_per_min * (1 + speed) * 60 / time_s(r)
    eff_speed = {}
    prod_by_machine = {}
    for m, spec in machines.items():
        base_cpm = float(spec["crafts_per_min"])
        mod = modules.get(m, {})
        speed = float(mod.get("speed", 0.0))
        prod = float(mod.get("prod", 0.0))
        prod_by_machine[m] = 1.0 + prod
        eff_speed[m] = base_cpm * (1.0 + speed)

    rec_names = list(recipes.keys())
    R = len(rec_names)

    # Build item universe & classify items
    all_items = set()
    out_by_r = []
    in_by_r = []
    time_s = []
    rec_machine = []
    for rname in rec_names:
        r = recipes[rname]
        m = r["machine"]
        rec_machine.append(m)
        time_s.append(float(r["time_s"]))
        ins = ordered(r.get("in", {}))
        outs = ordered(r.get("out", {}))
        in_by_r.append(ins)
        out_by_r.append(outs)
        for k in ins: all_items.add(k)
        for k in outs: all_items.add(k)
    all_items = sorted(all_items)

    # Effective outputs per craft apply productivity by machine type
    # eff_out[r][i] = out[i] * (1 + prod_m)
    eff_out = []
    for r_idx, rname in enumerate(rec_names):
        m = rec_machine[r_idx]
        p = prod_by_machine[m]
        o = {}
        for i, qty in out_by_r[r_idx].items():
            o[i] = float(qty) * p
        eff_out.append(o)

    # eff crafts/min capacity per recipe (for 1 machine of that type)
    # eff_crafts_per_min(r) = eff_speed[m] * 60 / time_s(r)
    eff_cpm_recipe = []
    for r_idx in range(R):
        m = rec_machine[r_idx]
        cpm_type = eff_speed[m]
        eff_cpm_recipe.append(cpm_type * 60.0 / time_s[r_idx])

    # Variables:
    # x_r >= 0 crafts/min per recipe r  (length R)
    # We’ll solve:
    #   A_eq x = b_eq   (item conservation for intermediates + exact target)
    #   A_ub x <= b_ub  (raw caps + machine caps)
    # Objective (Phase-2): minimize total machines = sum_r x_r / eff_cpm_recipe[r]
    # Phase-1: feasibility with exact target; if infeasible, binary search maximum target.

    # Determine for each item i whether it is (1) target, (2) raw-capped, or (3) intermediate
    is_produced = {i: False for i in all_items}
    for r_idx in range(R):
        for i in eff_out[r_idx]:
            is_produced[i] = True
    is_consumed = {i: False for i in all_items}
    for r_idx in range(R):
        for i in in_by_r[r_idx]:
            is_consumed[i] = True

    # Build conservation rows for all *intermediates* and the target (exact).
    # For each item i, coefficient for recipe r is: out_eff(i,r) - in(i,r)
    def build_conservation(target_rate):
        rows = []
        rhs = []
        for i in all_items:
            coeff = [0.0]*R
            for r_idx in range(R):
                out_i = eff_out[r_idx].get(i, 0.0)
                in_i = float(in_by_r[r_idx].get(i, 0.0))
                coeff[r_idx] = out_i - in_i
            if i == target_item:
                # exact production target
                rows.append(coeff)
                rhs.append(target_rate)
            else:
                # intermediate if produced by some recipe and not a raw-only item
                # A raw-only item is something that is consumed but never produced; those will be handled as inequalities.
                if is_produced[i]:
                    rows.append(coeff)
                    rhs.append(0.0)
                # otherwise skip (raw-only handled in inequalities)
        return rows, rhs

    # Raw caps: Net consumption of raw i is <= raw_caps[i]
    # Net consumption = sum_r in(i,r)*x_r - sum_r out_eff(i,r)*x_r = - (sum_r coeff)*x
    # But our conservation coeff was (out - in). For raw items with cap C:
    #    (sum_r (out - in) x_r) = balance_i <= 0 and >= -C
    # We enforce: (sum_r (out - in) x_r) >= -C  and (sum_r (out - in) x_r) <= 0
    # Turn into A_ub x <= b_ub form:
    #   1) -(sum coeff) x <= C
    #   2)  (sum coeff) x <= 0
    A_ub = []
    b_ub = []

    def push_ub(row, b):
        A_ub.append(row)
        b_ub.append(b)

    raw_only_items = []
    for i in all_items:
        if (not is_produced[i]) and (is_consumed[i] or i in raw_caps):
            raw_only_items.append(i)

    for i in raw_only_items:
        coeff = [0.0]*R
        for r_idx in range(R):
            out_i = eff_out[r_idx].get(i, 0.0)
            in_i = float(in_by_r[r_idx].get(i, 0.0))
            coeff[r_idx] = out_i - in_i
        cap = float(raw_caps.get(i, 0.0))
        # -(sum coeff) x <= cap
        push_ub([-c for c in coeff], cap + ABS_TOL)
        #  (sum coeff) x <= 0
        push_ub(coeff, ABS_TOL)

    # Machine caps per type: sum_{r uses m} x_r / eff_cpm_recipe[r] <= max_machines[m]
    for m, cap in max_machines.items():
        row = [0.0]*R
        for r_idx in range(R):
            if rec_machine[r_idx] == m:
                row[r_idx] = 1.0 / eff_cpm_recipe[r_idx]
        push_ub(row, float(cap) + ABS_TOL)

    bounds = [(0.0, None) for _ in range(R)]

    def solve_phase1_exact(target_rate):
        Aeq, beq = build_conservation(target_rate)
        if not Aeq:
            # Degenerate: no equalities except maybe target missing; enforce exact target on the item by adding a synthetic row using a virtual aggregation of outputs
            # If target isn’t produced by any recipe, infeasible immediately
            has_target_source = any(target_item in eff_out[r] for r in range(R))
            if not has_target_source:
                return None, None
        # Phase-1 objective: 0 (feasibility)
        c = [0.0]*R
        res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=Aeq, b_eq=beq, bounds=bounds, method="highs")
        if not res.success:
            return None, None
        # Phase-2: minimize total machines with same constraints
        c2 = [1.0/eff_cpm_recipe[r] for r in range(R)]
        res2 = linprog(c2, A_ub=A_ub, b_ub=b_ub, A_eq=Aeq, b_eq=beq, bounds=bounds, method="highs")
        if not res2.success:
            # fallback to feasible point
            return res.x, None
        return res2.x, res2.fun

    # If exact target infeasible, binary search the maximum feasible target
    lo, hi = 0.0, target_rate_req
    x_best = None
    # quick probe: try exact
    x_exact, _ = solve_phase1_exact(target_rate_req)
    if x_exact is not None:
        x_best = x_exact
        achieved_target = target_rate_req
    else:
        # binary search for max feasible target
        for _ in range(36):  # ~1e-10 precision on rate
            mid = 0.5*(lo+hi)
            x_try, _ = solve_phase1_exact(mid)
            if x_try is not None:
                x_best = x_try
                lo = mid
            else:
                hi = mid
        achieved_target = lo

    if x_best is None or achieved_target < target_rate_req - 1e-7:
        # Infeasible for requested; report bottlenecks via dual info by checking which caps bind
        hints = []
        # Check which machine caps tight under best found (if any)
        if x_best is not None:
            # evaluate usage vs caps
            usage_by_m = defaultdict(float)
            for r_idx in range(R):
                usage_by_m[rec_machine[r_idx]] += x_best[r_idx] / eff_cpm_recipe[r_idx]
            for m, cap in max_machines.items():
                if usage_by_m[m] >= float(cap) - 1e-7:
                    hints.append(f"{m} cap")
            # check raw
            for i in raw_only_items:
                s = 0.0
                for r_idx in range(R):
                    out_i = eff_out[r_idx].get(i, 0.0)
                    in_i = float(in_by_r[r_idx].get(i, 0.0))
                    s += (out_i - in_i) * x_best[r_idx]
                cons = -s
                cap = float(raw_caps.get(i, 0.0))
                if cons >= cap - 1e-7:
                    hints.append(f"{i} supply")
        print(json.dumps({
            "status": "infeasible",
            "max_feasible_target_per_min": achieved_target,
            "bottleneck_hint": sorted(set(hints))
        }, separators=(",", ":")))
        return

    # Build outputs
    per_recipe = OrderedDict()
    for r_idx, rname in enumerate(rec_names):
        per_recipe[rname] = float(x_best[r_idx])

    per_machine = defaultdict(float)
    for r_idx in range(R):
        per_machine[rec_machine[r_idx]] += x_best[r_idx] / eff_cpm_recipe[r_idx]
    per_machine = ordered({k: float(v) for k, v in per_machine.items()})

    raw_use = OrderedDict()
    for i in raw_caps.keys():
        s = 0.0
        for r_idx in range(R):
            out_i = eff_out[r_idx].get(i, 0.0)
            in_i = float(in_by_r[r_idx].get(i, 0.0))
            s += (out_i - in_i) * x_best[r_idx]
        cons = max(0.0, -s)  # net consumption only
        raw_use[i] = cons

    print(json.dumps({
        "status": "ok",
        "per_recipe_crafts_per_min": per_recipe,
        "per_machine_counts": per_machine,
        "raw_consumption_per_min": raw_use
    }, separators=(",", ":")))

if __name__ == "__main__":
    main()