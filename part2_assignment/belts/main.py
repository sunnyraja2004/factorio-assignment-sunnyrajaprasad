# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NvK0ZenoVq5U0JvX2TNqIe3l-Tp2x6Kx
"""

#!/usr/bin/env python3
import sys, json
from collections import defaultdict, deque

ABS_TOL = 1e-9

# Deterministic Dinic (BFS/DFS orders are lexicographic on node names; edges appended in sorted order)

class Dinic:
    def __init__(self):
        self.adj = defaultdict(list)   # node -> list of edge indices
        self.edge = []                 # list of [u, v, cap, flow]
        self.nodes = set()

    def add_edge(self, u, v, cap):
        self.nodes.add(u); self.nodes.add(v)
        uid = len(self.edge)
        self.edge.append([u, v, cap, 0.0])
        self.edge.append([v, u, 0.0, 0.0])
        self.adj[u].append(uid)
        self.adj[v].append(uid ^ 1)

    def bfs(self, s, t):
        lvl = {n: -1 for n in self.nodes}
        q = deque([s])
        lvl[s] = 0
        while q:
            u = q.popleft()
            # deterministic: visit out-edges in lex order by head
            out = sorted(self.adj[u], key=lambda ei: self.edge[ei][1])
            for ei in out:
                u1, v1, cap, flow = self.edge[ei]
                if lvl[v1] < 0 and cap - flow > ABS_TOL:
                    lvl[v1] = lvl[u] + 1
                    q.append(v1)
        return lvl

    def send(self, u, t, f, it, lvl):
        if u == t:
            return f
        # deterministic: iterate edges in lex order by head, but reuse iterator indices
        while it[u] < len(self.adj[u]):
            ei = sorted(self.adj[u], key=lambda e: self.edge[e][1])[it[u]]
            u1, v1, cap, flow = self.edge[ei]
            if lvl[v1] == lvl[u] + 1 and cap - flow > ABS_TOL:
                pushed = self.send(v1, t, min(f, cap - flow), it, lvl)
                if pushed > 0:
                    self.edge[ei][3] += pushed
                    self.edge[ei ^ 1][3] -= pushed
                    return pushed
            it[u] += 1
        return 0.0

    def maxflow(self, s, t):
        flow = 0.0
        while True:
            lvl = self.bfs(s, t)
            if lvl.get(t, -1) < 0: break
            it = {n: 0 for n in self.nodes}
            while True:
                pushed = self.send(s, t, float("inf"), it, lvl)
                if pushed <= ABS_TOL: break
                flow += pushed
        return flow

    def reachable_from(self, s):
        # residual graph reachability
        vis = set()
        q = deque([s]); vis.add(s)
        while q:
            u = q.popleft()
            out = sorted(self.adj[u], key=lambda ei: self.edge[ei][1])
            for ei in out:
                u1, v1, cap, flow = self.edge[ei]
                if v1 not in vis and cap - flow > ABS_TOL:
                    vis.add(v1); q.append(v1)
        return sorted(vis)

def main():
    data = json.load(sys.stdin)
    # Input schema we assume:
    # {
    #   "nodes": ["s1","a","b","sink", ...],
    #   "edges": [{"from": "a","to":"b","lo":0,"hi":100}, ...],
    #   "sources": {"s1": 900, "s2": 600},
    #   "sink": "sink",
    #   "node_caps": {"a": 1200, "b": 800}  # optional; cap is throughput (in==out) cap
    # }
    nodes = sorted(data["nodes"])
    sink = data["sink"]
    sources = dict(sorted(data["sources"].items()))
    node_caps = dict(sorted(data.get("node_caps", {}).items()))
    edges = data["edges"]

    # 1) Node capacity handling via splitting v -> v_in -> v_out
    # We’ll maintain a mapping: name -> (in_name, out_name)
    def v_in(v):  return f"{v}#in" if v in node_caps else v
    def v_out(v): return f"{v}#out" if v in node_caps else v

    cap_graph = Dinic()
    for v, cap in node_caps.items():
        cap_graph.add_edge(v_in(v), v_out(v), float(cap))

    # 2) Lower bound transform
    # For each edge u->v (lo,hi):
    #   add capacity (hi - lo) on transformed graph from u_out to v_in
    #   track node imbalance: demand[v] += lo ; demand[u] -= lo
    demand = defaultdict(float)
    for e in edges:
        u, v = e["from"], e["to"]
        lo = float(e.get("lo", 0.0))
        hi = float(e["hi"])
        if hi + 1e-12 < lo:
            print(json.dumps({
                "status": "infeasible",
                "cut_reachable": [],
                "deficit": {"demand_balance": lo - hi, "tight_nodes": [v], "tight_edges": [{"from": u, "to": v, "flow_needed": lo - hi}]}
            }))
            return
        cap_graph.add_edge(v_out(u), v_in(v), hi - lo)
        demand[v_in(v)] += lo
        demand[v_out(u)] -= lo

    # Add source-to-sink supplies: we’ll connect sources to sink AFTER feasibility of lower bounds
    total_supply = 0.0
    for s, amt in sources.items():
        total_supply += float(amt)

    # 3) Feasibility for lower bounds: connect super source/sink
    SS, TT = "#SS", "#TT"
    need = 0.0
    for node in set(cap_graph.nodes):
        bal = demand[node]
        if bal > ABS_TOL:
            cap_graph.add_edge(SS, node, bal)
            need += bal
        elif bal < -ABS_TOL:
            cap_graph.add_edge(node, TT, -bal)

    flowed = cap_graph.maxflow(SS, TT)
    if flowed + 1e-7 < need:
        # Infeasible lower bounds; report certificate = reachable from SS
        cut = cap_graph.reachable_from(SS)
        # try to list tight edges crossing cut
        tight_edges = []
        in_cut = set(cut)
        for ei in range(0, len(cap_graph.edge), 2):
            u, v, cap, flow = cap_graph.edge[ei]
            if u in in_cut and v not in in_cut and cap - flow <= ABS_TOL and cap > 0:
                # edge is saturated
                tight_edges.append({"from": u, "to": v, "flow_needed": ABS_TOL})
        print(json.dumps({
            "status": "infeasible",
            "cut_reachable": cut,
            "deficit": {
                "demand_balance": float(need - flowed),
                "tight_nodes": sorted([n for n in in_cut if n.endswith("#out") or n in nodes]),
                "tight_edges": tight_edges
            }
        }, separators=(",", ":")))
        return

    # 4) Now build main flow graph for actual supplies to the single sink
    # We use a new Dinic to avoid residual garbage from feasibility phase.
    G = Dinic()
    for v, cap in node_caps.items():
        G.add_edge(v_in(v), v_out(v), float(cap))
    for e in edges:
        u, v = e["from"], e["to"]
        lo = float(e.get("lo", 0.0))
        hi = float(e["hi"])
        G.add_edge(v_out(u), v_in(v), hi - lo)

    # connect sources -> sink: add edges (s_out -> sink_in) with cap=supply
    for s, amt in sources.items():
        G.add_edge(v_out(s), v_in(sink), float(amt))

    max_flow = G.maxflow(v_out(list(sources.keys())[0]), v_in(sink))  # we don’t actually need this return; we just want a feasible circulation w/ supplies

    # Recover original flows by adding lower bounds
    # To extract per-edge flows, look up the matching edge we added: (v_out(u) -> v_in(v)) and add lo
    flow_map = {}
    # Build index for quick lookup
    fwd_edges_index = defaultdict(list)
    for idx in range(0, len(G.edge), 2):
        u, v, cap, fl = G.edge[idx]
        fwd_edges_index[(u, v)].append(idx)

    result_flows = []
    for e in sorted(edges, key=lambda x: (x["from"], x["to"])):
        u, v = e["from"], e["to"]
        lo = float(e.get("lo", 0.0))
        hi = float(e["hi"])
        u2, v2 = v_out(u), v_in(v)
        # pick the earliest edge deterministically
        idx_list = fwd_edges_index.get((u2, v2), [])
        if not idx_list:
            f = lo  # edge didn’t exist (hi==lo==0)
        else:
            ei = sorted(idx_list)[0]
            _, _, _, fl = G.edge[ei]
            f = fl + lo
        result_flows.append({"from": u, "to": v, "flow": float(max(0.0, f))})

    print(json.dumps({
        "status": "ok",
        "max_flow_per_min": float(total_supply),
        "flows": result_flows
    }, separators=(",", ":")))

if __name__ == "__main__":
    main()